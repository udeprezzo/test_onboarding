(function() {

    angular.module('ComplexWork',['MstResolver']).config(['MstResolverProvider', function(MstResolverProvider) {

        MstResolverProvider.setConfig({
            fslOperationRemoteAction: complex.remoteActions.getFslOperation,
            apiVersion: '38.0',
            fieldNames: complex.fieldNames.FslOperationFieldNames
        });

    }]);

    mainCtrl.$inject = ['$scope', 'superService', 'TIME_DEP_FIELDS', '$q', 'MstResolver'];

    angular.module('ComplexWork').controller('mainCtrl', mainCtrl);

    function mainCtrl($scope, superService, TIME_DEP_FIELDS, $q, MstResolver) {

        $scope.schedulingProgress = [];

        // check if we open this page from the gantts lightbox
        $scope.inGantt = (window.document.location.href.indexOf('ingantt') > -1);

        $scope.newServicesSelected = {
            sa1: null,
            sa2: null
        };

        $scope.selectCurrentInLb = function() {

            for (let i=0; i<$scope.relatedServices.byAccount.length; i++) {
                if ($scope.relatedServices.byAccount[i].Id === complex.serviceId) {
                    $scope.newServicesSelected[$scope.selectNewService] = $scope.relatedServices.byAccount[i];
                }
            }

            for (let i=0; i<$scope.relatedServices.byWorkorder.length; i++) {
                if ($scope.relatedServices.byWorkorder[i].Id === complex.serviceId) {
                    $scope.newServicesSelected[$scope.selectNewService] = $scope.relatedServices.byWorkorder[i];
                }
            }

            $scope.selectNewService = null;
        };

        $scope.schedulingFinished = false;
        $scope.timeDepSelect = "Same Start";
        $scope.sameResource = false;
        $scope.selectNewService = null;
        $scope.fields = [];
        $scope.statusTranslations = complex.statusTranslations;
        $scope.showServiceLightbox = {
            id: null,
            name: null
        };
        $scope.chain = {};
        $scope.relatedServices = {
            byAccount: null,
            byWorkorder: null
        };
        $scope.saPage = document.location.href.indexOf('servlet') > -1 ? '../apex/' + complex.serviceLightboxUrl : complex.serviceLightboxUrl;

        $scope.recenterGraph = superService.recenterGraph;

        $scope.isInChain = function (id) {
            return superService.checkIfServicesInChain($scope.chain, id, id);
        };

        $scope.isScheduleRunning = function() {
            return schedulingRunning;
        };

        var assignedResources = {},
            removeRunning = false,
            addRunning = false,
            schedulingRunning = false;


        // init - get related services to the current service
        superService.getRelatedServices()
            .then(function(services) {
                $scope.relatedServices.byAccount = services.account;
                $scope.relatedServices.byWorkorder = services.workorder;
            })
            .catch(handleError);


        // init - get SA fieldsets
        superService.getFieldsets()
            .then(function(fields) {
                $scope.fields = fields;
            })
            .catch(handleError);


        // init - get chain
        superService.getMstChain().then(generateChainData).catch(handleError);


        // validate before adding new time dep
        function validateTimeDependency(dep, same) {

            // already running
            if (addRunning) {
                return false;
            } else {
                addRunning = true;
            }


            // schedule running
            if (schedulingRunning) {
                alert(complex.labels.Please22);
                addRunning = false;
                return false;
            }

            // need 2 services
            if (!$scope.newServicesSelected.sa1 || !$scope.newServicesSelected.sa2) {
                alert(complex.labels.Please33);
                addRunning = false;
                return false;
            }

            // same service was chosen
            if ($scope.newServicesSelected.sa1 == $scope.newServicesSelected.sa2) {
                alert(complex.labels.Please77);
                addRunning = false;
                return false;
            }

            // chain is empty, one of the service must be current
            if ($scope.isChainEmpty() && $scope.newServicesSelected.sa1.Id !== complex.serviceId && $scope.newServicesSelected.sa2.Id !== complex.serviceId) {
                alert(complex.labels.Please11);
                addRunning = false;
                return false;
            }

            // one of the services is not in the chain
            if (!$scope.isChainEmpty() && !superService.checkIfServicesInChain($scope.chain, $scope.newServicesSelected.sa1.Id, $scope.newServicesSelected.sa2.Id)) {
                alert(complex.labels.Please00);
                addRunning = false;
                return false;
            }

            // dep is none but not same
            if (!same && dep === 'None') {
                alert(complex.labels.Please99);
                addRunning = false;
                return false;
            }


            // same start and same resource
            if (same && dep === 'Same Start') {
                alert(complex.labels.Please44);
                addRunning = false;
                return false;
            }

            return true;

        }


        // add new time dep to the chain
        $scope.addTimeDependency = function(sa1, sa2, dep, same) {

            if (!validateTimeDependency(dep, same)) {
                return;
            }

            dep = dep === 'None' ? null : dep;

            superService.addTimeDependency(sa1, sa2, dep, same)
                .then(generateChainData)
                .then(function() {
                    $scope.newServicesSelected.sa1 = null;
                    $scope.newServicesSelected.sa2 = null;
                })
                .finally(function() {
                    addRunning = false;
                })
                .catch(handleError)
        };


        // remove time dependency
        $scope.removeTimeDependency = function(depId) {

            // schedule running
            if (schedulingRunning) {
                alert(complex.labels.Please22);
                return;
            }


            if (removeRunning) {
                return;
            } else {
                removeRunning = true;
            }

            if (!confirm(complex.labels.confirmComplex)) {
                removeRunning = false;
                return;
            }

            superService.removeTimeDependency(depId)
                .then(generateChainData)
                .finally(function() {
                    removeRunning = false;
                })
                .catch(handleError)
        };


        // basic error handling function
        function handleError(error) {
            alert(error.message);
            console.error('%ckolodner was notified ¯\\_(ツ)_/¯', 'background:#353535;color:#7ff734; padding: 5px');
            console.error(error);
        }


        // generate chain data to Angular from SF object
        function generateChainData(result) {

            let chain = result.dependencies || [];


            // generate assigned resource object
            if (result.assignedResources) {
                result.assignedResources.forEach(function(ar) {
                    if (ar.ServiceResource) {
                        assignedResources[ar.ServiceAppointmentId] = ar.ServiceResource.Name;
                    }
                });
            }

            $scope.chain = {};

            // create the parsed dependency array
            chain.forEach(function(dep) {

                $scope.chain[dep[TIME_DEP_FIELDS().sa1]] = $scope.chain[dep[TIME_DEP_FIELDS().sa1]] ||
                    {
                        id:             dep[TIME_DEP_FIELDS().sa1r].Id,
                        name:           dep[TIME_DEP_FIELDS().sa1r].AppointmentNumber,
                        relations:      [],
                        isScheduled:    !!dep[TIME_DEP_FIELDS().sa1r].SchedStartTime,
                        start:          dep[TIME_DEP_FIELDS().sa1r].SchedStartTime ? dep[TIME_DEP_FIELDS().sa1r].SchedStartTime : '',
                        status:         $scope.statusTranslations[dep[TIME_DEP_FIELDS().sa1r].Status],
                        statusCategory: dep[TIME_DEP_FIELDS().sa1r].StatusCategory
                    };

                $scope.chain[dep[TIME_DEP_FIELDS().sa1]].relations.push(
                    {
                        relationId:     dep.Id,
                        id:             dep[TIME_DEP_FIELDS().sa2],
                        name:           dep[TIME_DEP_FIELDS().sa2r].AppointmentNumber,
                        dependency:     dep[TIME_DEP_FIELDS().dependency],
                        sameResource:   dep[TIME_DEP_FIELDS().sameResource],
                        isScheduled:    !!dep[TIME_DEP_FIELDS().sa2r].SchedStartTime,
                        start:          dep[TIME_DEP_FIELDS().sa2r].SchedStartTime ? dep[TIME_DEP_FIELDS().sa2r].SchedStartTime : '',
                        status:         $scope.statusTranslations[dep[TIME_DEP_FIELDS().sa2r].Status],
                        statusCategory: dep[TIME_DEP_FIELDS().sa2r].StatusCategory
                    }
                );
            });

            updateGraph();
        }


        // updates the nomnoml graph
        function updateGraph() {
            superService.drawGraph(superService.formatGraph($scope.chain, assignedResources));
        }


        // timezone convertion
        $scope.formatFieldToDisplay = function (value, field) {

            if (field.Type.indexOf('DATE') > -1) {
                return moment(value).tz(complex.timeZone).format('lll');
            }
            else if (field.APIName == 'Status') {
                return $scope.statusTranslations[value] || value;
            } else {
                return value;
            }

        };


        // is chain empty
        $scope.isChainEmpty = function() {
            return Object.keys($scope.chain).length === 0;
        };


        // schedule by order
        $scope.scheduleByOrder = function() {

            if (schedulingRunning) {
                return;
            }

            schedulingRunning = true;

            superService.getTreeOrderForScheduling()
                .then(function(order) {
                    startScheduling(order);
                })
                .finally(function() {
                    // nothing for now
                })
                .catch(handleError);
        };

        $scope.displayScheduleResult = function(scheduleResult) {

            if (scheduleResult.scheduling) {
                return complex.labels.schedulingComplexz;
            }

            if (scheduleResult.result) {

                if (Array.isArray(scheduleResult.result) && scheduleResult.result.length === 0) {
                    return 'No candidates were found'
                } else if (Array.isArray(scheduleResult.result) && scheduleResult.result[0]) {
                    return 'Scheduled to ' + scheduleResult.result[0].Resource.Name + ' starting on ' + moment(scheduleResult.result[0].Service.SchedStartTime).tz(complex.timeZone).format('lll');
                } else {
                    return scheduleResult.result;
                }
            }

        };


        function startScheduling(order) {

            var currentService = 0,
                fslOperationPromise = $q.defer(),
                isComplexSchedulingAvailable = false;

            // init promises
            order.forEach(function(o) { o.promise = $q.defer(); });

            $scope.schedulingProgress = [];
            $scope.schedulingFinished = true;


            // start scheduling
            scheduleRecursive();

            function scheduleRecursive() {

                if (order.length === currentService) {
                    superService.getMstChain().then(generateChainData).catch(handleError);
                    schedulingRunning = false;
                    return;
                }

                let length = $scope.schedulingProgress.push({
                    service: order[currentService],
                    result: null,
                    error: false,
                    scheduling: true
                });


                superService.scheduleService(order[currentService].ServiceId)
                    .then(function(schedulingResult) {

                        console.log(schedulingResult);

                        if (Array.isArray(schedulingResult) && schedulingResult[0] && schedulingResult[0].LongOperationId) {

                            isComplexSchedulingAvailable = true;

                            MstResolver.getUpdates(schedulingResult[0].LongOperationId).then(function(schedulingResult) {
                                console.log(schedulingResult);
                                parseFslOperationResult(schedulingResult.fslOperation.result);
                            }).catch(ex => {
                                console.error(ex);
                                console.log(order[currentService]);

                                $scope.schedulingProgress[$scope.schedulingProgress.length-1] = {
                                    service: order[currentService],
                                    result: ex,
                                    error: true,
                                    scheduling: false
                                };



                            }).finally(() => {
                                scheduleRecursive(++currentService);
                            });

                        }

                        $scope.schedulingProgress[length-1].result = schedulingResult;
                    })
                    .finally(function() {

                        if (isComplexSchedulingAvailable) {
                            return;

                        }


                        $scope.schedulingProgress[length-1].scheduling = false;
                        scheduleRecursive(++currentService);
                    })
                    .catch(ex => {
                        //handleError(ex);
                        $scope.schedulingProgress[length-1].result = ex.message;
                        $scope.schedulingProgress[length-1].error = true;
                    });

            }

        }


        function parseFslOperationResult(result) {

            $scope.schedulingProgress = [];

            result.forEach(result => {
                $scope.schedulingProgress.push({
                    service: result.Service,
                    result: [result],
                    error: false,
                    scheduling: false
                });
            });

        }




    }




}());