'use strict';

(function () {
    angular.module('serviceExpert').controller('ctrlGantt', ['$scope', '$rootScope', '$q', 'sfdcService', 'servicesService', 'utils', 'calendarsService', 'userSettingsManager', 'resourceFilterHelper', 'monthlyViewHelperService', 'ResourcesAndTerritoriesService', 'TimePhasedDataService', 'StateService', 'CapacityLightboxService', 'ResourceSmallMenu', 'AbsencesService', 'SkillsService', 'DeltaService', 'AbsenceLightboxService', 'ResourceLightboxService', 'ServiceAppointmentLightboxService', 'kpiCalculationsService', 'ResourceCapacitiesService', 'SERVICE_STATUS', 'SERVICE_CATEGORY', 'GetSlotsService', 'bulkScheduleService', 'GeneralLightbox', function ($scope, $rootScope, $q, sfdcService, servicesService, utils, calendarsService, userSettingsManager, resourceFilterHelper, monthlyViewHelperService, ResourcesAndTerritoriesService, TimePhasedDataService, StateService, CapacityLightboxService, ResourceSmallMenu, AbsencesService, SkillsService, DeltaService, AbsenceLightboxService, ResourceLightboxService, ServiceAppointmentLightboxService, kpiCalculationsService, ResourceCapacitiesService, SERVICE_STATUS, SERVICE_CATEGORY, GetSlotsService, bulkScheduleService, GeneralLightbox) {

        var __lastEventRightClicked = '',
            __lastBreakRightClicked = '',
            __lastModifiedEvent = {},
            __firstTimeLoad = true,
            __serviceContextMenu = new dhtmlXMenuObject({
            parent: 'contextZone_A',
            context: true
        }),
            __multiServicesContextMenu = new dhtmlXMenuObject({
            parent: 'contextZone_A',
            context: true
        });

        $scope.selectedGanttServices = {}; // selected services on the gantt
        $scope.resourceFilterHelper = resourceFilterHelper;
        $scope.resources = []; // Array passed to the scheduler, containing all resources
        $scope.searchEmployee = ''; // Search resource string
        $scope.resourceFieldToSortyBy = 'Name'; // Search resource string
        $scope.successfullyScheduled = 0; // Used for the auto schedule feature - TODO: group to 1 object
        $scope.currentSchedulingIndex = 0; // Used for the auto schedule feature - TODO: group to 1 object
        $scope.ganttLocked = false; // Gantt lock toggle
        $scope.timelineName = ''; // Current timeline name
        $scope.nowTimespans = []; // Current "now" marks for the different locations
        $scope.selectedSkills = {}; // Selected skills for the skills filter
        $scope.pinnedStatusesSF = CustomSettings.pinnedStatusesSF.split(',');
        $scope.hasCustomPermission = utils.hasCustomPermission;

        $rootScope.statusTranslations = utils.statusTranslations;

        $scope.$watch('resourceFilterHelper', function () {
            $('#resourceExplainCrap').html($scope.resourceFilterHelper.generateFilterExplanation($scope.resourceFilters.showWorkingResource));
        }, true);

        // absence types
        AbsencesService.getEmployeeAbsenceTypes().then(function (types) {
            $scope.nonAvailabilityTypes = types;

            $scope.defaultDragNa = { // Default parameters for the NA creation widget
                selectedNaDuration: JSON.parse(userSettingsManager.GetUserSettingsProperty('Drag_Na_Duration__c')) || 60,
                selectedNaType: userSettingsManager.GetUserSettingsProperty('Drag_Na_Type__c') || $scope.nonAvailabilityTypes[0],
                selectedNaLabel: userSettingsManager.GetUserSettingsProperty('Drag_Na_Label__c')
            };
        });

        $scope.businessHoursRange = { // Business hours settings (filter)
            start: utils.ganttSettings.startHour,
            end: utils.ganttSettings.finishHour,
            includeWeekends: userSettingsManager.GetUserSettingsProperty('Include_Weekends__c')
        };

        $scope.resourceFilters = { // Resource filter help stuff
            showWorkingResource: false,
            resourcesWorkingInRange: {}
        };

        $scope.isInConsole = StateService.isInConsole; // Are we in console?
        $scope.openConsoleTab = utils.openConsoleTab; // Function to open tabs in console

        $scope.capacityFields = monthlyViewHelperService.capacityCalculationFields; // monthly filter fields


        // get selected objects
        Object.defineProperty($scope.selectedGanttServices, 'getSelected', {
            enumrable: false,
            value: function value() {
                var selected = [];
                for (var id in this) {
                    this[id] && selected.push(id);
                }

                return selected;
            }
        });

        // is gantt filter applied?
        $scope.isGanttFilterApplied = function () {
            return $scope.skillsFilter || resourceFilterHelper.isResourceFilterApplied() || $scope.resourceFilters.showWorkingResource;
        };

        // set cached dom elements
        if (!cachedDomElements.timesDragFix) cachedDomElements.timesDragFix = $('#timesDragFix');

        var busHoursFirstWatch = true;

        $scope.$watchCollection('businessHoursRange', watchBusinessHours);

        function watchBusinessHours() {
            if (busHoursFirstWatch) {
                busHoursFirstWatch = false;
                return;
            }

            setHoursToDisplay($scope.businessHoursRange.start, $scope.businessHoursRange.end, $scope.businessHoursRange.includeWeekends);

            // we need gantts events to run, that's why we are not using updateView()
            scheduler.setCurrentView();

            utils.ganttSettings.startHour = $scope.businessHoursRange.start;
            utils.ganttSettings.finishHour = $scope.businessHoursRange.end;

            // save to local storage
            var propAndValues = {};
            propAndValues['Gantt_View_Start_Hour__c'] = utils.ganttSettings.startHour;
            propAndValues['Gantt_View_Finish_Hour__c'] = utils.ganttSettings.finishHour;
            propAndValues['Include_Weekends__c'] = $scope.businessHoursRange.includeWeekends;
            userSettingsManager.SetUserSettingProperties(propAndValues);
        }

        // get resources
        ResourcesAndTerritoriesService.promises.resources().then(function () {
            $scope.resources = ResourcesAndTerritoriesService.getResources;
        });

        $scope.saveDragNaDefaults = function (field) {
            switch (field) {
                case 'duration':
                    userSettingsManager.SetUserSettingsProperty('Drag_Na_Duration__c', $scope.defaultDragNa.selectedNaDuration);
                    break;
                case 'type':
                    userSettingsManager.SetUserSettingsProperty('Drag_Na_Type__c', $scope.defaultDragNa.selectedNaType);
                    break;
                case 'label':
                    userSettingsManager.SetUserSettingsProperty('Drag_Na_Label__c', $scope.defaultDragNa.selectedNaLabel);
                    break;
            }
        };

        $scope.getTimePhasedObjects = function (fromArrows) {

            var start = scheduler.getState().min_date,
                finish = scheduler.getState().max_date;

            // check if date was changed by arrows (keys or UI buttons)
            if (typeof fromArrows !== 'undefined') {

                if (fromArrows == 'left') {
                    finish.setDate(start.getDate() + 1);
                    start.setDate(start.getDate() - 1);
                } else if (fromArrows == 'right') {
                    start.setDate(finish.getDate() - 1);
                    finish.setDate(finish.getDate() + 1);
                }
            }

            // Not changed by arrows
            else {
                    start.setDate(start.getDate() - 1);
                    finish.setDate(finish.getDate() + 1);
                }

            return TimePhasedDataService.getTimePhasedObjects(start, finish).then(function (data) {

                $rootScope.$broadcast('ganttFinishedLoadingServices');

                if (__firstTimeLoad) {

                    __firstTimeLoad = false;
                    scheduler.updateView();

                    var idToShow = null;

                    if (document.URL.indexOf('service=') > -1) {
                        idToShow = document.URL.substr(document.URL.indexOf('service=') + 8, 18);
                    }

                    if (scheduler._events[idToShow]) {

                        scheduler._select_id = idToShow;
                        scheduler.select(idToShow);

                        setTimeout(function () {
                            utils.showOnGantt(idToShow);
                        }, 0);
                    } else if (idToShow) {
                        alert(customLabels.cant_display_service);
                    }
                }
            });
        };

        // post to chatter - if getting an array, send it. if getting true then send the selected array
        function postToChatter(servicesIdsArray, sayWhat) {

            if (sayWhat === '') sayWhat = prompt(customLabels.msg_to_post_to_chatter, '');

            if (sayWhat === null) {
                return;
            }

            if (sayWhat === '') {
                alert(customLabels.no_empty_msg_to_chatter);
                return;
            }

            if (servicesIdsArray.length == 1) servicesService.recentlyUsed[servicesIdsArray[0]] = true;

            servicesService.postToChatter(servicesIdsArray, sayWhat).then(function (numOfMentions) {});
        }

        // this will be called when the user click on the left/right arrows on the top of the gantt
        $scope.changeDatesByArrows = function (direction) {
            $scope.getTimePhasedObjects(direction);
        };

        // double clicking an event will open the lightbox
        scheduler.attachEvent('onDblClick', function (id, e) {

            utils.safeApply($scope, function () {
                if (scheduler.getEvent(id).type === 'service') {
                    // set recently used
                    servicesService.recentlyUsed[id] = true;
                    ServiceAppointmentLightboxService.open(id);
                } else if (scheduler.getEvent(id).type === 'contractorcapacity') {
                    CapacityLightboxService.open(id);
                } else {
                    AbsenceLightboxService.open(id);
                }
            });
        });

        // folder click
        scheduler.attachEvent("onBeforeFolderToggle", function (section, isOpen, allSections) {

            utils.safeApply($scope, function () {
                StateService.ganttOpenedTerritories[section.key] = isOpen;
            });

            return true;
        });

        scheduler.attachEvent('onViewChange', function (new_mode, new_date) {
            utils.safeApply($scope, function () {

                // set name on timeline selector
                switch (scheduler._mode) {
                    case 'ZoomLevel2':
                        $scope.timelineName = customLabels.In_Day;
                        break;

                    case 'ZoomLevel3':
                        $scope.timelineName = customLabels.Daily;
                        break;

                    case 'ZoomLevel4':
                        $scope.timelineName = customLabels.X2_Days;
                        break;

                    case 'ZoomLevel5':
                        $scope.timelineName = customLabels.X3_Days;
                        break;

                    case 'ZoomLevel6':
                        $scope.timelineName = customLabels.Weekly;
                        break;

                    case 'MonthlyView':
                        $scope.timelineName = customLabels.Utilization;
                        break;

                    case 'MTDView':
                        $scope.timelineName = customLabels.MDTVIEW;
                        break;
                }

                $('#MonthlyLocationViewTooltip').remove();
                drawTimeNow();
                scheduler.updateView();

                kpiCalculationsService.calculateKpis();
            });
        });

        // select services
        scheduler.attachEvent('onBeforeDrag', function (id, mode, e) {
            var key,
                ctrlOrCommandPressed = e.ctrlKey || e.metaKey;

            // allow dragging shifts but not create them
            if (!id || mode == 'create') {

                // unselect all other services
                if (!ctrlOrCommandPressed) {
                    for (key in $scope.selectedGanttServices) {
                        $scope.selectedGanttServices[key] = false;
                        if (scheduler.getRenderedEvent(key)) scheduler.updateEvent(key);
                    }
                }

                return false;
            }

            //enable multi select with ctrl key - only for services
            if (id && scheduler.getEvent(id).type == 'service') {

                if (ctrlOrCommandPressed) {
                    __multiServicesContextMenu.hide();

                    if (!$scope.selectedGanttServices[id]) {
                        $scope.selectedGanttServices[id] = true;

                        // scheduler.getEvent(id).selected = true;
                        scheduler.updateEvent(id);
                    } else {
                        $scope.selectedGanttServices[id] = false;
                        scheduler.updateEvent(id);
                    }

                    return false;
                } else {
                    //catch first event
                    $scope.selectedGanttServices[id] = true;

                    //unselect all other services
                    for (key in $scope.selectedGanttServices) {
                        if (key != id) {
                            $scope.selectedGanttServices[key] = false;

                            // scheduler.getEvent(key).selected = false;
                            if (scheduler.getEvent(key) && scheduler.getSection(scheduler.getEvent(key).resourceId)) scheduler.updateEvent(key);
                        }
                    }
                }
            } else {

                // unselect all other services
                if (!ctrlOrCommandPressed) {
                    if ($scope.selectedGanttServices.getSelected().length >= 1) {
                        for (key in $scope.selectedGanttServices) {
                            $scope.selectedGanttServices[key] = false;
                            if (scheduler.getRenderedEvent(key)) scheduler.updateEvent(key);
                        }
                    }
                }
            }

            // allow dragging only for services (new - drag NA also)
            if (scheduler.getEvent(id).type != 'service' && scheduler.getEvent(id).type != 'na') return;

            // don't allow dragging pinned services
            if (id && scheduler.getEvent(id).type == 'service' && scheduler.getEvent(id).pinned && preventUpdateOfPinned) return;

            return true;
        });

        // Unselect all other services
        function unselectMultiSelected() {
            for (var key in $scope.selectedGanttServices) {
                delete $scope.selectedGanttServices[key];
            }
        }

        // used to be $watch with true
        $scope.$watchCollection('selectedGanttServices', function (newVal, oldVal) {
            globalSelectedGanttServices = $scope.selectedGanttServices;
        });

        // jump to date with DHTMLX mini calendar
        $scope.jumpToDate = function () {
            if (scheduler.isCalendarVisible()) {
                scheduler.destroyCalendar();
            } else {
                scheduler.renderCalendar({
                    position: 'JumpToDate',
                    date: scheduler._date,
                    navigation: true,
                    handler: function handler(date, calendar) {
                        scheduler.setCurrentView(date);
                        scheduler.destroyCalendar();
                        $scope.changeDatesByArrows();
                    }
                });
            }
        };

        // ------------------------------ context menu break ------------------------------


        var breakContextMenu = new dhtmlXMenuObject({
            parent: 'contextZone_A',
            context: true
        });

        breakContextMenu.addNewChild(breakContextMenu.topId, 0, 'details', utils.getSVGIconHTML(lsdIcons.info) + customLabels.Details, false);

        breakContextMenu.attachEvent('onClick', function (id, zoneId, cas) {

            switch (id) {

                case 'details':
                    utils.safeApply($scope, function () {
                        AbsenceLightboxService.open(__lastBreakRightClicked);
                    });

                    break;

                case 'delete':
                    utils.safeApply($scope, function () {

                        if (!confirm(customLabels.naDeleteConfirm)) return;

                        AbsencesService.deleteAbsence(__lastBreakRightClicked).then(function (isDeleted) {
                            if (isDeleted) {
                                //delete $scope.absences[__lastBreakRightClicked];
                                scheduler.deleteEvent(__lastBreakRightClicked);
                            } else {
                                alert(customLabels.Failed_To_Delete_Break);
                            }
                        });
                    });
                    break;
            }
        });

        // ------------------------------ context menu ------------------------------


        // init the service context menu (for single service clicked)
        (function initSingleServiceContextMenu() {

            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 0, 'details', utils.getSVGIconHTML(lsdIcons.info) + customLabels.Details, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 3, 'reschedule', utils.getSVGIconHTML(lsdIcons.calendar) + customLabels.Reschedule, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 4, 'candidates', utils.getSVGIconHTML(lsdIcons.candidates) + customLabels.Get_Candidates, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 10, 'reshuffle', utils.getSVGIconHTML(lsdIcons.retweet) + customLabels.Reshuffle, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 11, 'groupNearby', utils.getSVGIconHTML(lsdIcons.groupNearby) + customLabels.GroupNearby, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 5, 'status', utils.getSVGIconHTML(lsdIcons.replace) + customLabels.Change_status + "<i class='fa fa-caret-right status-change-carret'></i>", false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 6, 'map', utils.getSVGIconHTML(lsdIcons.world) + customLabels.Map, false);
            __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 8, 'unschedule', utils.getSVGIconHTML(lsdIcons.na) + customLabels.Unschedule, false);

            // show the post to chatter action only if chatter is enabled for service
            if (fieldTrackingEnabled.service) {
                __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 7, 'chatter', utils.getSVGIconHTML(lsdIcons.chat) + customLabels.Chatter + "<i id='chatterArrowContext' class='fa fa-caret-right chatter-carret'></i>", false);
                __serviceContextMenu.addNewChild('chatter', 0, 'chatter_welldone', utils.getSVGIconHTML(lsdIcons.like) + customLabels.well_done, false);
                __serviceContextMenu.addNewChild('chatter', 1, 'chatter_hurryup', utils.getSVGIconHTML(lsdIcons.hurry) + customLabels.Hurry_up, false);
                __serviceContextMenu.addNewChild('chatter', 2, 'chatter_requestupdate', utils.getSVGIconHTML(lsdIcons.help) + customLabels.Request_update, false);
                __serviceContextMenu.addNewChild('chatter', 3, 'chatter_custom', utils.getSVGIconHTML(lsdIcons.threedots) + customLabels.Custom_message, false);
            }
        })();

        function addContextMenuItems(event_id) {

            var isPinnedStatus = false;
            for (var i = 0; i < $scope.pinnedStatusesSF.length; i++) {
                if (scheduler._events[event_id].status === $scope.pinnedStatusesSF[i]) isPinnedStatus = true;
            }

            //is pinned or pinned SF status? remove schedule and cands
            if (scheduler._events[event_id].pinned || isPinnedStatus) {
                __serviceContextMenu.hideItem('reschedule');
                __serviceContextMenu.hideItem('candidates');
                __serviceContextMenu.hideItem('unschedule');
                __serviceContextMenu.hideItem('status');
                __serviceContextMenu.hideItem('reshuffle');
                __serviceContextMenu.hideItem('groupNearby');
            } else {
                __serviceContextMenu.showItem('reschedule');
                __serviceContextMenu.showItem('candidates');
                __serviceContextMenu.showItem('unschedule');
                __serviceContextMenu.showItem('status');
                __serviceContextMenu.showItem('reshuffle');
                __serviceContextMenu.showItem('groupNearby');
            }

            // if pinned, cant change status
            if (scheduler._events[event_id].pinned) {
                __serviceContextMenu.hideItem('status');
            } else {
                __serviceContextMenu.showItem('status');
            }

            // if no geolocation - cant group near by
            if (!scheduler._events[event_id].latitude || !scheduler._events[event_id].longitude || !utils.hasCustomPermission('Group_Nearby')) {
                __serviceContextMenu.hideItem('groupNearby');
            } else {
                __serviceContextMenu.showItem('groupNearby');
            }

            //check custom permission for reschedule
            if (!utils.hasCustomPermission('Schedule')) {
                __serviceContextMenu.hideItem('reschedule');
            } else {
                __serviceContextMenu.showItem('reschedule');
            }

            //check custom permission for reshuffle
            if (!utils.hasCustomPermission('Reshuffle')) {
                __serviceContextMenu.hideItem('reshuffle');
            } else {
                __serviceContextMenu.showItem('reshuffle');
            }

            // need to add "show related" ?
            __serviceContextMenu.removeItem('showRelated');
            if (scheduler._events[event_id].isServiceInChain || scheduler._events[event_id].relatedTo || scheduler._events[event_id].relatedFather) {
                __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 5, 'showRelated', utils.getSVGIconHTML(lsdIcons.related) + customLabels.Show_related, false);
            }

            // remove map from contextMenu.
            if (!StateService.isMapEnabled() || scheduler._events[event_id].latitude === null) {
                __serviceContextMenu.hideItem('map');
            } else {
                __serviceContextMenu.showItem('map');
            }

            // check if unflagged or flagged
            __serviceContextMenu.removeItem('flag');
            if (servicesService.flagged[event_id]) __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 1, 'flag', "<span class='emptyFlag'>" + utils.getSVGIconHTML(lsdIcons.flag) + "</span> " + customLabels.Unflag, false);else __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 1, 'flag', "<span class='fullFlag'>" + utils.getSVGIconHTML(lsdIcons.flag) + "</span> " + customLabels.Flag, false);

            // check if pinned
            __serviceContextMenu.removeItem('pin');
            if (scheduler._events[event_id].pinned) __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 9, 'pin', "<span class='emptyFlag'>" + utils.getSVGIconHTML(lsdIcons.unpin) + "</span> " + customLabels.Unpin, false);else __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 9, 'pin', "<span class='fullFlag'>" + utils.getSVGIconHTML(lsdIcons.pin) + "</span> " + customLabels.Pin, false);

            __serviceContextMenu.removeItem('consoleTab');
            if ($scope.isInConsole()) {
                __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 1, 'consoleTab', utils.getSVGIconHTML(lsdIcons.external) + customLabels.Open_Tab, false);
            }
        }

        var menuItemsIdsToStatuses = {};

        // update context menu to consider the status flow
        function updateContextMenuStatusFlow(from) {

            var cssStatusName = void 0,
                i = 0;

            if (!_.isEmpty(utils.statusFlow)) {

                if (utils.statusFlow[from] && utils.statusFlow[from].length > 0) {
                    __serviceContextMenu.removeItem('status');
                    __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 5, 'status', utils.getSVGIconHTML(lsdIcons.replace) + customLabels.Change_status + "<i class='fa fa-caret-right status-change-carret'></i>", false);
                } else {
                    __serviceContextMenu.removeItem('status');
                    return;
                }
            } else {

                __serviceContextMenu.removeItem('status');
                __serviceContextMenu.addNewChild(__serviceContextMenu.topId, 5, 'status', utils.getSVGIconHTML(lsdIcons.replace) + customLabels.Change_status + "<i class='fa fa-caret-right status-change-carret'></i>", false);

                for (var st in utils.statuses) {
                    cssStatusName = 'ContextMenu_' + utils.statusTranslations[utils.statuses[st]].split(' ').join('');
                    __serviceContextMenu.addNewChild('status', i, 'status_change_' + i, "<span class='StatusColorChanger " + cssStatusName + ' ' + utils.getCSSClassForContext(utils.statusTranslations[utils.statuses[st]], SERVICE_STATUS) + "'></span>" + utils.statusTranslations[utils.statuses[st]], false);
                    menuItemsIdsToStatuses['status_change_' + i++] = utils.statuses[st];
                }

                return; // using default, all statuses allowed
            }

            menuItemsIdsToStatuses = {};

            for (i = 0; i < utils.statusFlow[from].length; i++) {
                cssStatusName = 'ContextMenu_' + utils.statusFlow[from][i].split(' ').join('');
                __serviceContextMenu.addNewChild('status', i, 'status_change_' + i, "<span class='StatusColorChanger " + cssStatusName + ' ' + utils.getCSSClassForContext(utils.statusFlow[from][i], SERVICE_STATUS) + "'></span>" + utils.statusTranslations[utils.statusFlow[from][i]], false);
                menuItemsIdsToStatuses['status_change_' + i] = utils.statusFlow[from][i];
            }
        }

        scheduler.attachEvent('onContextMenu', function (event_id, native_event_object) {

            // scheduler is locked
            if (scheduler.config.readonly) return true;

            if (event_id && scheduler.getEvent(event_id).type != 'service' && scheduler.getEvent(event_id).type != 'break' && scheduler.getEvent(event_id).type != 'na') return false;

            if (event_id) {

                scheduler.dhtmlXTooltip.hide();

                var posx = 0,
                    posy = 0;

                if (native_event_object.pageX || native_event_object.pageY) {
                    posx = native_event_object.pageX;
                    posy = native_event_object.pageY;
                } else if (native_event_object.clientX || native_event_object.clientY) {
                    posx = native_event_object.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                    posy = native_event_object.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                }

                if ($scope.selectedGanttServices.getSelected().length < 2) {
                    if (scheduler._events[event_id].type == 'break') {
                        breakContextMenu.removeItem('delete');
                        breakContextMenu.showContextMenu(posx, posy);
                        __lastBreakRightClicked = event_id;
                        return false; // prevent default action and propagation
                    }

                    if (scheduler._events[event_id].type == 'na') {
                        breakContextMenu.removeItem('delete');
                        breakContextMenu.addNewChild(breakContextMenu.topId, 1, 'delete', utils.getSVGIconHTML(lsdIcons.delete) + customLabels.Delete, false);
                        breakContextMenu.showContextMenu(posx, posy);
                        __lastBreakRightClicked = event_id;
                        return false; // prevent default action and propagation
                    }

                    addContextMenuItems(event_id);

                    if (!scheduler.getEvent(event_id).pinned) {
                        updateContextMenuStatusFlow(scheduler.getEvent(event_id).status);
                    }

                    __serviceContextMenu.showContextMenu(posx, posy);
                    __lastEventRightClicked = event_id;

                    return false;
                } else {

                    __multiServicesContextMenu.removeItem('selectedNumber');
                    __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 0, 'selectedNumber', "<i class='fa fa-check-square-o'></i> " + customLabels.x_services_selected.replaceAll($scope.selectedGanttServices.getSelected().length), true);
                    __multiServicesContextMenu.removeItem('status');
                    __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 4, 'status', utils.getSVGIconHTML(lsdIcons.replace) + customLabels.Change_status + "<i class='fa fa-caret-right status-change-carret'></i>", false);

                    menuItemsIdsToStatuses = {};
                    var i = 0;

                    for (var st in utils.statuses) {
                        var cssStatusName = 'ContextMenu_' + utils.statusTranslations[utils.statuses[st]].split(' ').join('');
                        __multiServicesContextMenu.addNewChild('status', i, 'status_change_' + i, "<span class='StatusColorChanger " + cssStatusName + ' ' + utils.getCSSClassForContext(utils.statusTranslations[utils.statuses[st]], SERVICE_STATUS) + "'></span>" + utils.statusTranslations[utils.statuses[st]], false);
                        menuItemsIdsToStatuses['status_change_' + i++] = utils.statuses[st];
                    }

                    __multiServicesContextMenu.showContextMenu(posx, posy);

                    return false;
                }
            }

            __lastEventRightClicked = '';
            __lastBreakRightClicked = '';

            return true;
        });

        __serviceContextMenu.attachEvent('onShow', function (id) {
            contextShown = true;
        });

        __serviceContextMenu.attachEvent('onHide', function (id) {
            contextShown = false;
        });

        breakContextMenu.attachEvent('onShow', function (id) {
            contextShown = true;
        });

        breakContextMenu.attachEvent('onHide', function (id) {
            contextShown = false;
        });

        __serviceContextMenu.attachEvent('onClick', function (id, zoneId, cas) {

            $scope.$evalAsync(function () {
                switch (id) {

                    case 'details':
                        utils.safeApply($scope, function () {
                            ServiceAppointmentLightboxService.open(__lastEventRightClicked);
                        });

                        break;

                    case 'consoleTab':
                        $scope.openConsoleTab(null, __lastEventRightClicked);
                        break;

                    case 'flag':
                        $scope.$evalAsync(function () {
                            servicesService.flagged[__lastEventRightClicked] = !servicesService.flagged[__lastEventRightClicked];
                            scheduler.updateEvent(__lastEventRightClicked);
                        });

                        break;

                    case 'pin':

                        servicesService.changePin([scheduler._events[__lastEventRightClicked].id], !scheduler._events[__lastEventRightClicked].pinned).then(function () {
                            return scheduler.updateView();
                        });
                        break;

                    case 'reschedule':
                        $scope.$evalAsync(function () {
                            servicesService.autoScheduleService(__lastEventRightClicked).then(function (updatedObjects) {

                                if (updatedObjects.services.length === 0) {
                                    alert(customLabels.NoCandidates);
                                }

                                servicesService.drawServicesAndAbsences(updatedObjects.services, updatedObjects.absences);
                            }).catch(function (err) {
                                var name = TimePhasedDataService.serviceAppointments()[__lastEventRightClicked].name;
                                utils.addNotification(name + ' - ' + customLabels.Action_Could_Not_Be_Performed, err.message, function () {
                                    ServiceAppointmentLightboxService.open(__lastEventRightClicked);
                                });
                            });
                        });
                        break;
                    case 'reshuffle':
                        $scope.$evalAsync(function () {
                            sfdcService.runReshuffle(__lastEventRightClicked, StateService.selectedPolicyId).then(function (optReq) {
                                DeltaService.updateOptimizationRequest(optReq);
                            }, function () {
                                utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err.message);
                            });
                        });
                        break;
                    case 'groupNearby':
                        $scope.$evalAsync(function () {
                            sfdcService.runGroupNearby(__lastEventRightClicked, StateService.selectedPolicyId).then(function (optReq) {
                                DeltaService.updateOptimizationRequest(optReq);
                            }, function () {
                                utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err.message);
                            });
                        });
                        break;

                    case 'candidates':
                        GetSlotsService.get(__lastEventRightClicked);
                        break;

                    case 'chatter_welldone':
                        postToChatter([__lastEventRightClicked], customLabels.Well_done_mate);
                        break;

                    case 'chatter_hurryup':
                        postToChatter([__lastEventRightClicked], customLabels.hurry_up_with_this_service);
                        break;

                    case 'chatter_requestupdate':
                        postToChatter([__lastEventRightClicked], customLabels.please_update_service);
                        break;

                    case 'chatter_custom':
                        postToChatter([__lastEventRightClicked], '');
                        break;

                    case 'unschedule':
                        $scope.$evalAsync(function () {
                            unscheduleServices([__lastEventRightClicked]);
                        });
                        break;

                    case 'map':
                        $scope.showOnMap(__lastEventRightClicked);
                        break;

                    case 'showRelated':

                        if (usingNewMstModel) {
                            GeneralLightbox.open('Related Services For ' + scheduler._events[__lastEventRightClicked].name, mstPage + '?ingantt=true&id=' + __lastEventRightClicked);
                            return;
                        }

                        if (scheduler._events[scheduler._events[__lastEventRightClicked].relatedFather]) {
                            utils.showOnGantt(scheduler._events[__lastEventRightClicked].relatedFather);
                            return;
                        } else if (scheduler._events[scheduler._events[__lastEventRightClicked].relatedTo]) {
                            utils.showOnGantt(scheduler._events[__lastEventRightClicked].relatedTo);
                            return;
                        }

                        if (scheduler._events[__lastEventRightClicked].relatedFather) alert(customLabels.related_x_not_scheduled_no_display.replaceAll(TimePhasedDataService.serviceAppointments()[scheduler._events[__lastEventRightClicked].relatedFather].name));else alert(customLabels.related_x_not_scheduled_no_display.replaceAll(TimePhasedDataService.serviceAppointments()[scheduler._events[__lastEventRightClicked].relatedTo].name));

                        break;

                    default:
                        $scope.$evalAsync(function () {
                            changeStatus([__lastEventRightClicked], menuItemsIdsToStatuses[id]);
                        });
                        break;
                }
            });
        });

        $('.dhtmlxMenu_dhx_skyblue_SubLevelArea_Polygon').mouseover(function () {
            scheduler.dhtmlXTooltip.hide();
        });

        // ------------------------------ context menu end ------------------------------

        // ------------------------------ Multi Select Context Menu ---------------------


        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 1, 'flag', utils.getSVGIconHTML(lsdIcons.flag) + customLabels.Flag, false);
        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 2, 'unflag', "<span class='emptyFlag'>" + utils.getSVGIconHTML(lsdIcons.flag) + "</span>" + customLabels.Unflag, false);
        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 3, 'reschedule', utils.getSVGIconHTML(lsdIcons.calendar) + customLabels.Reschedule, false);
        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 5, 'unschedule', utils.getSVGIconHTML(lsdIcons.na) + customLabels.Unschedule, false);
        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 7, 'pin', utils.getSVGIconHTML(lsdIcons.pin) + customLabels.Pin, false);
        __multiServicesContextMenu.addNewChild(__multiServicesContextMenu.topId, 8, 'unpin', "<span class='emptyFlag'>" + utils.getSVGIconHTML(lsdIcons.unpin) + "</span>" + customLabels.Unpin, false);

        __multiServicesContextMenu.attachEvent('onShow', function (id) {
            contextShown = true;
        });

        __multiServicesContextMenu.attachEvent('onHide', function (id) {
            contextShown = false;
        });

        __multiServicesContextMenu.attachEvent('onClick', function (id, zoneId, cas) {

            $scope.$evalAsync(function () {
                switch (id) {

                    case 'flag':
                        utils.safeApply($scope, function () {
                            MultiServiceSetFlag(true);
                        });

                        break;

                    case 'unflag':
                        utils.safeApply($scope, function () {
                            MultiServiceSetFlag(false);
                        });

                        break;

                    case 'reschedule':
                        bulkScheduleService.schedule($scope.selectedGanttServices.getSelected());
                        break;

                    case 'pin':

                        servicesService.changePin($scope.selectedGanttServices.getSelected(), true).then(function () {
                            return scheduler.updateView();
                        });
                        break;

                    case 'unpin':

                        servicesService.changePin($scope.selectedGanttServices.getSelected(), false).then(function () {
                            return scheduler.updateView();
                        });
                        break;

                    case 'unschedule':
                        unscheduleServices($scope.selectedGanttServices.getSelected());
                        break;

                    default:
                        changeStatus($scope.selectedGanttServices.getSelected(), menuItemsIdsToStatuses[id]);
                        break;
                }
            });
        });

        function MultiServiceSetFlag(val) {
            for (var id in $scope.selectedGanttServices) {

                if (!$scope.selectedGanttServices[id]) continue;

                //if (servicesService.flagged[id]) {
                servicesService.flagged[id] = val;
                //}
            }

            scheduler.updateView();
        }

        // ------------------------------ Multi Select Context Menu End -----------------


        $scope.lockGanttToggle = function () {
            scheduler.config.readonly = !scheduler.config.readonly;
            $scope.ganttLocked = scheduler.config.readonly;
        };

        $scope.unSelecteAllSkills = function () {
            for (var key in $scope.selectedSkills) {
                $scope.selectedSkills[key] = false;
            }
        };

        $scope.selectAllSkills = function () {
            for (var key in $scope.selectedSkills) {
                $scope.selectedSkills[key] = true;
            }
        };

        // get skills
        SkillsService.promises.skills().then(function (skills) {
            $scope.skills = skills;
        });

        scheduler.attachEvent('onYScaleClick', function (index, section, e) {
            var classNames = ["resourceMenuBtn", "resourceMenuIcon"];
            for (var i = 0; i < classNames.length; i++) {
                if (e.target.classList && e.target.classList.contains(classNames[i]) || e.target.parentNode && e.target.parentNode.classList.contains(classNames[i])) {

                    ResourceSmallMenu.open(section.resourceId, section.key, e.target);
                    return;
                }
            }

            if (!section.children) {
                ResourceLightboxService.open(section.resourceId, section.key);
            }
        });

        // key press events
        $scope.$on('keypress', function (event, e) {

            $('#MonthlyViewTooltip').remove();

            if (StateService.isLightboxOpened()) return;

            // check if there is an input in focus
            if ($('*:focus').is('textarea, input')) return;

            switch (e.which) {

                // ENTER - open service (if selected)
                case 13:
                    if (scheduler._select_id !== '' && scheduler._select_id && scheduler.getEvent(scheduler._select_id).type === 'service') {
                        servicesService.recentlyUsed[scheduler._selected_id] = true;
                        ServiceAppointmentLightboxService.open(scheduler._select_id);
                    }
                    break;

                // left arrow
                case 37:
                    $('.dhx_cal_prev_button').click();
                    break;

                // up arrow:
                case 38:
                    var topScroll = $('.dhx_cal_data').scrollTop();
                    $('.dhx_cal_data').scrollTop(topScroll - 30);
                    break;

                // right arrow
                case 39:
                    $('.dhx_cal_next_button').click();
                    break;

                // down arrow:
                case 40:
                    topScroll = $('.dhx_cal_data').scrollTop();
                    $('.dhx_cal_data').scrollTop(topScroll + 30);
                    break;

                // W - open external (work order / woli)
                case 87:
                    if (scheduler._select_id !== '' && scheduler._select_id && scheduler.getEvent(scheduler._select_id).type == 'service' && scheduler.getEvent(scheduler._select_id).parentRecord) {

                        if ($scope.isInConsole()) {
                            sforce.console.generateConsoleUrl(['/' + scheduler._events[scheduler._select_id].parentRecord], function (result) {
                                sforce.console.openConsoleUrl(null, result.consoleUrl, true);
                            });
                        } else {
                            window.open('../' + scheduler._events[scheduler._select_id].parentRecord);
                        }
                    }

                    break;

                // W - open external (service appointment)
                case 83:
                    if (scheduler._select_id !== '' && scheduler._select_id && scheduler.getEvent(scheduler._select_id).type == 'service') {

                        if ($scope.isInConsole()) {
                            sforce.console.generateConsoleUrl(['/' + scheduler._select_id], function (result) {
                                sforce.console.openConsoleUrl(null, result.consoleUrl, true);
                            });
                        } else {
                            window.open('../' + scheduler._select_id);
                        }
                    }

                    break;

                // T - jump to today
                case 84:
                    $scope.jumpToToday();
                    break;

                // F - Flag/unflag selected
                case 70:
                    if ($scope.selectedGanttServices.getSelected().length === 1) {
                        if (scheduler._select_id !== '' && scheduler._select_id && scheduler.getEvent(scheduler._select_id).type === 'service') {
                            if (servicesService.flagged[scheduler._select_id]) {
                                servicesService.flagged[scheduler._select_id] = false;
                                scheduler.updateEvent(scheduler._select_id);
                            } else {
                                servicesService.flagged[scheduler._select_id] = true;
                                scheduler.updateEvent(scheduler._select_id);
                            }
                        }
                    }

                    break;

                // 0 - In Day timeline
                case 48:
                    $scope.changeTimeline(0);
                    break;

                // 0NUMPAD - daily timeline
                case 96:
                    $scope.changeTimeline(0);
                    break;

                // 1 - daily timeline
                case 49:
                    $scope.changeTimeline(1);
                    break;

                // 1NUMPAD - daily timeline
                case 97:
                    $scope.changeTimeline(1);
                    break;

                // 2 - 2days timeline
                case 50:
                    $scope.changeTimeline(2);
                    break;

                // 2NUMPAD - 2days timeline
                case 98:
                    $scope.changeTimeline(2);
                    break;

                // 3 - 3days timeline
                case 51:
                    $scope.changeTimeline(3);
                    break;

                // 3NUMPAD - 3days timeline
                case 99:
                    $scope.changeTimeline(3);
                    break;

                // 7 - weekly timeline
                case 55:
                    $scope.changeTimeline(7);
                    break;

                // mdt
                case 77:
                    utils.hasCustomPermission('MDT_View') && monthlyViewSettings.isMonthlyAvailable && $scope.changeTimeline(35);
                    break;

                // Utilization
                case 85:
                    utils.hasCustomPermission('Monthly_Utilization') && monthlyViewSettings.isMonthlyAvailable && $scope.changeTimeline(30);
                    break;

                // 7NUMPAD - weekly timeline
                case 103:
                    $scope.changeTimeline(7);
                    break;
            }
        });

        $scope.changeTimeline = function (timeline) {

            var currentDate = scheduler._min_date,
                oldDate = scheduler._max_date,
                newView = void 0;

            switch (timeline) {

                case 0:
                    newView = 'ZoomLevel2';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.In_Day;
                    break;

                case 1:
                    newView = 'ZoomLevel3';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.Daily;
                    break;

                case 2:
                    newView = 'ZoomLevel4';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.X2_Days;
                    break;

                case 3:
                    newView = 'ZoomLevel5';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.X3_Days;
                    break;

                case 7:
                    newView = 'ZoomLevel6';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.Weekly;
                    break;

                case 30:
                    newView = 'MonthlyView';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.Utilization;
                    break;

                case 35:
                    newView = 'MTDView';
                    if (newView == scheduler._mode) return;

                    $scope.timelineName = customLabels.MDTVIEW;
                    break;

            }

            scheduler.setCurrentView(currentDate, newView);
            $scope.changeDatesByArrows(oldDate);
        };

        function drawTimeNow() {

            // if the scheduler wasn't initalized yet, don't try to draw anything
            if (!scheduler._is_initialized() || !$scope.datalessMethods) return;

            for (var i = 0; i < $scope.nowTimespans.length; i++) {
                scheduler.deleteMarkedTimespan($scope.nowTimespans[i]);
            } //scheduler.updateView();
            $scope.nowTimespans.length = 0;

            var currentLocations = scheduler.serverList('resources'),
                businessHours = getMinAndMaxHoursToDisplay();

            for (i = 0; i < currentLocations.length; i++) {

                var nowLocal = new Date(),
                    now = new Date(nowLocal.valueOf() + nowLocal.getTimezoneOffset() * 60000);

                if (useLocationTimezone) {
                    now.setMinutes(now.getMinutes() + utils.getLocationOffset(now, currentLocations[i].key));
                } else {
                    now = utils.convertDateBetweenTimeZones(now, "GMT", userTimeZone);
                }

                if (!(businessHours.min <= now.getHours() && now.getHours() < businessHours.max) || $scope.datalessMethods.isDateInsideWeekend(now) || scheduler._mode === 'MonthlyView') continue;

                var section = {};
                section[scheduler.getState().mode] = [];

                for (var j = 0; j < currentLocations[i].children.length; j++) {
                    section[scheduler.getState().mode].push(currentLocations[i].children[j].key);
                }

                $scope.nowTimespans.push(scheduler.addMarkedTimespan({
                    start_date: now,
                    end_date: scheduler.date.add(now, 1, 'minute'),
                    css: 'dhx_now_time dhx_matrix_now_time',
                    sections: section
                }));
            }
        }

        // draw red lines of  "now"
        setInterval(drawTimeNow, 1000 * 60 * 10);

        $scope.jumpToToday = function () {

            var today = new Date();
            today.setHours(0);
            today.setMinutes(0);
            today.setSeconds(0);
            today.setMilliseconds(0);

            scheduler.setCurrentView(today);

            $scope.changeDatesByArrows();
        };

        $rootScope.$on('afterShowEvent', function () {

            setTimeout(function () {
                $scope.changeDatesByArrows();
                drawTimeNow();
                scheduler.updateView();
                $rootScope.$broadcast('updateKpis');
            }, 800);
        });

        $scope.showOnMap = function (serviceId) {
            $rootScope.$broadcast('showServiceOnMap', serviceId);
            utils.safeApply($scope);
        };

        scheduler.attachEvent('onBeforeEventChanged', function (ev, e, is_new, original) {

            var newstart = void 0,
                newend = void 0,
                oldstart = void 0,
                oldend = void 0;

            //if resource wasn't changed in drag - check if dragged minutes is above minimum drag setting
            if (ev.resourceId == original.resourceId) {
                newstart = ev.start_date.getTime(), newend = ev.end_date.getTime(), oldstart = original.start_date.getTime(), oldend = original.end_date.getTime();

                if (Math.abs((newstart - oldstart) / 1000 / 60) < minDragMinutes || Math.abs((newend - oldend) / 1000 / 60) < minDragMinutes) {
                    cachedDomElements.timesDragFix.hide();
                    return false;
                }
            } else {
                //resource was changed - cancel absence drag
                if (ev.type == 'na') return false;
            }

            if (StateService.areContractorsSupported()) {

                //dont drag service to contractor with no capacity
                if (ev.type == 'service' && ResourcesAndTerritoriesService.getResources()[ev.getGanttResource()].isCapacityBased) {
                    for (var key in TimePhasedDataService.resourceCapacities()) {
                        var capacityObj = TimePhasedDataService.resourceCapacities()[key];
                        if (capacityObj.resource != ResourcesAndTerritoriesService.getResources()[ev.getGanttResource()].id) continue;

                        if (ev.start.getTime() >= capacityObj.start_date.getTime() && ev.start.getTime() <= capacityObj.end_date.getTime()) {
                            ev.resourceBeforeDrag = original.resourceId;
                            ev.eventBeforeDrag = original;

                            // set gantt jumps
                            setMinutesForEventChanges(ev);

                            return true;
                        }
                    }

                    cachedDomElements.timesDragFix.hide();
                    alert(customLabels.serviceCantBeAssignedWithoutCapacity);
                    return false;
                }
            }

            __lastModifiedEvent = GanttService.copy(original);
            snapTo = e.ctrlKey;

            // set gantt jumps
            setMinutesForEventChanges(ev);

            // this is used to reduce the capacity of the right resource
            ev.resourceBeforeDrag = original.resourceId;
            ev.eventBeforeDrag = original;

            return true;
        });

        $scope.updateMonthlyKpi = function () {
            scheduler._mode === 'MonthlyView' && scheduler.updateView();
        };

        // ************************************************************************************************************
        // ************************************************************************************************************
        // *********************************** NEW STUFF FOR NEW DATA MODEL STUFF *************************************
        // ************************************************************************************************************
        // ************************************************************************************************************

        // this will handle service appointments and absences to draw on the gantt when first loading and when moving between dates
        $rootScope.$on('gotNewTimePhasedObjects', function (broadcastEvent, timePhasedObjects) {
            servicesService.drawServicesAndAbsences(timePhasedObjects.serviceAppointments, timePhasedObjects.resourceAbsences, [], timePhasedObjects.resourceCapacities);

            if (!_.isEmpty(timePhasedObjects.serviceAppointments) || !_.isEmpty(timePhasedObjects.resourceAbsences) || !_.isEmpty(timePhasedObjects.resourceCapacities)) {
                servicesService.checkRules(utils.getServicesBetweenDates(timePhasedObjects.start, timePhasedObjects.finish)).then(function () {
                    return scheduler.updateView();
                });
            }
        });

        // register to delta - services
        DeltaService.register('services', function (services) {
            servicesService.drawServicesAndAbsences(services.updated || [], [], services.deleted || []);
        });

        // register to delta - absences
        DeltaService.register('absences', function (absences) {
            servicesService.drawServicesAndAbsences([], absences.updated || [], absences.deleted || []);
        });

        // register to delta - capacities
        DeltaService.register('capacities', function (capacities) {
            servicesService.drawServicesAndAbsences([], [], capacities.deleted || [], capacities.updated || []);
        });

        // register to rule checking (so we won't need to do so twice)
        DeltaService.register('rules', function (ids) {
            servicesService.checkRules(ids).then(function () {
                return scheduler.updateView();
            });
        });

        // unschedule services - if getting an array, send it. if getting true then send the selected array
        function unscheduleServices(servicesIdsArray) {

            if (!confirm(customLabels.are_you_sure_unschedule)) {
                return true;
            }

            // we will need this to check rules later on
            var resourcesIds = [],
                servicesToUnschedule = [];

            servicesIdsArray.forEach(function (id) {
                servicesToUnschedule.push(TimePhasedDataService.serviceAppointments()[id]);
                resourcesIds.push(TimePhasedDataService.serviceAppointments()[id].resource);
                servicesService.recentlyUsed[id] = true;
            });

            servicesService.unscheduleServices(servicesIdsArray).then(function (resultObjects) {
                servicesService.drawServicesAndAbsences(resultObjects.services, resultObjects.absences);
                kpiCalculationsService.calculateKpis();
                unselectMultiSelected();
            }).catch(function (err) {
                utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err.message || customLabels.user_is_not_allowed_to_perform_action);
            });
        }

        // dispatch services - if getting an array, send it. if getting true then send the selected array
        function changeStatus(servicesIdsArray, status) {

            if (status === SERVICE_STATUS.CANCELED && !confirm(customLabels.AreYouSureYouWantToCancel)) {
                return true;
            }

            // we will need this to check rules later on
            var resourcesIds = [],
                servicesToUnschedule = [];

            servicesIdsArray.forEach(function (id) {
                servicesToUnschedule.push(TimePhasedDataService.serviceAppointments()[id]);
                resourcesIds.push(TimePhasedDataService.serviceAppointments()[id].resource);
                servicesService.recentlyUsed[id] = true;
            });

            servicesService.changeStatus(servicesIdsArray, status).then(function (resultObjects) {

                servicesService.drawServicesAndAbsences(resultObjects.services);
                unselectMultiSelected();
            }).catch(function (err) {
                utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err.message || customLabels.user_is_not_allowed_to_perform_action);
            });
        }

        function setMinutesForEventChanges(ev) {

            var currentMinutes = (ev.start_date.getMinutes() + ev.travelTo / 60) % 60,
                serviceLengthInMs = ev.type === 'na' ? ev.end - ev.start : ev.schedEndTime - ev.schedStartTime,
                nearDown = currentMinutes % serviceJumpsOnGantt,
                nearUp = serviceJumpsOnGantt - currentMinutes % serviceJumpsOnGantt;

            if (nearDown === 0) {
                return;
            }

            if (nearDown > nearUp) {
                ev.start_date = new Date(ev.start_date.getTime() + nearUp * 60 * 1000);
            } else {
                ev.start_date = new Date(ev.start_date.getTime() - nearDown * 60 * 1000);
            }

            // set end date (add travel from)
            ev.end_date = new Date(ev.start_date.getTime() + serviceLengthInMs + ev.travelFrom * 1000 + ev.travelTo * 1000);

            ev.schedStartTime = ev.start_date.getTime() + ev.travelTo * 1000;
            ev.schedEndTime = ev.end_date.getTime() - ev.travelFrom * 1000;
        }

        // dragging event (na/service) on the gantt
        scheduler.attachEvent('onEventChanged', function (id, ev) {

            // we can only drag services and NAs
            if (ev.type !== 'service' && ev.type !== 'na') {
                return;
            }

            utils.safeApply($scope, function () {

                // NA was moved
                if (ev.type === 'na') {

                    AbsencesService.saveChangesToAbsence(__lastModifiedEvent, ev).then(function (parsedObjects) {
                        servicesService.drawServicesAndAbsences(parsedObjects.services || [], parsedObjects.absences || []);
                    }).catch(function (err) {
                        console.warn('Couldn\'t update absence');

                        if (err[0].error) {
                            utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err[0].error);
                        } else {
                            utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err.message || customLabels.user_is_not_allowed_to_perform_action);
                        }
                        scheduler.parse([err[1]], 'json');
                    });

                    return;
                }

                // update service
                servicesService.saveChangesToServiceAppointment(__lastModifiedEvent, ev).then(function (parsedUpdatedObjects) {

                    var updatedServices = [],
                        updatedAbsences = [];

                    parsedUpdatedObjects.absences.forEach(function (absence) {
                        absence.isScheduled() && absence.setGanttResource(TimePhasedDataService.resourcesAndTerritories(), utils.generateResourceId);
                        updatedAbsences.push(absence);
                    });

                    parsedUpdatedObjects.services.forEach(function (service) {
                        service.isScheduled() && service.setGanttResource(TimePhasedDataService.resourcesAndTerritories(), utils.generateResourceId);
                        updatedServices.push(service);
                    });

                    servicesService.drawServicesAndAbsences(updatedServices, updatedAbsences);
                }).catch(function (err) {
                    console.warn('Couldn\'t update service. ' + err[2]);
                    utils.addNotification(customLabels.Action_Could_Not_Be_Performed, err[2] || customLabels.user_is_not_allowed_to_perform_action);
                    scheduler.parse([err[1]], 'json');
                });
            });
        });

        // finished with the slots panel
        $scope.$on('GotSlotsEnded', function () {
            //$scope.searchEmployee = '';
        });

        // jump to date from slots panel
        $scope.$on('JumpToDate', function (e, date) {
            scheduler.setCurrentView(date);
            $scope.changeDatesByArrows();
        });

        // when getting slots from the GetSlotsService
        $scope.$on('GotSlots', function (e, data) {

            // filter resources
            //$scope.searchEmployee = data.resourceToFilter;

            var currentBusinessHours = getMinAndMaxHoursToDisplay();

            // filter business hours
            if (data.minDateOfCandidate.getHours() < currentBusinessHours.min || data.minDateOfCandidate.getHours() >= currentBusinessHours.max) {

                if (confirm(customLabels.confirmChangeBusinessHours)) {

                    if (data.minDateOfCandidate.getHours() < currentBusinessHours.min) $scope.businessHoursRange.start = data.minDateOfCandidate.getHours();else $scope.businessHoursRange.end = 24;

                    watchBusinessHours();
                }
            }
        });
    }]);
})();